#!/usr/bin/env node
/**
 * pm2.js - Unified PM2 launcher for DEXBot2
 *
 * One-command startup for DEXBot2 with PM2 process management.
 * Handles all setup required before starting bot processes:
 *
 * 1. BitShares Connection
 *    - Waits for BitShares network connection
 *    - Suppresses debug output to keep terminal clean
 *
 * 2. PM2 Installation Check
 *    - Detects local and global PM2 installations
 *    - Prompts to install PM2 if missing
 *
 * 3. Ecosystem Configuration Generation
 *    - Reads bot definitions from profiles/bots.json
 *    - Generates profiles/ecosystem.config.js with absolute paths
 *    - Filters only active bots (active !== false)
 *    - If bot-name provided, filters to only that bot
 *
 * 4. Master Password Authentication
 *    - Prompts user interactively for master password
 *    - Suppresses BitShares logs during prompt
 *    - Password kept in RAM only (never saved to disk)
 *
 * 5. PM2 Startup
 *    - Passes master password via MASTER_PASSWORD environment variable
 *    - Each bot process receives password from env var
 *    - Spawns configured bots as PM2 managed processes
 *
 * Usage:
 *   node pm2.js              - Full setup and start all active bots
 *   node pm2.js <bot-name>   - Start only the specified bot via PM2
 *   node dexbot.js pm2       - Same as 'node pm2.js' via CLI
 *   npm run pm2:unlock-start - Same as 'node pm2.js' via npm script
 *
 * Security:
 *   - Master password never written to disk
 *   - No .env files created
 *   - Password only in process memory
 *   - Cleared when process exits
 *
 * Output:
 *   - Clean startup messages (BitShares connection status)
 *   - Ecosystem generation confirmation
 *   - Active bot count
 *   - PM2 management commands reference
 */

const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');

const ROOT = __dirname;
const PROFILES_DIR = path.join(ROOT, 'profiles');
const BOTS_JSON = path.join(PROFILES_DIR, 'bots.json');
const ECOSYSTEM_FILE = path.join(PROFILES_DIR, 'ecosystem.config.js');
const LOGS_DIR = path.join(PROFILES_DIR, 'logs');

// Parse JSON with comments support
function parseJsonWithComments(content) {
    const cleaned = content
        .replace(/\/\*[\s\S]*?\*\//g, '')
        .split('\n')
        .map(line => line.replace(/\/\/.*$/, ''))
        .join('\n');
    return JSON.parse(cleaned);
}

// Generate ecosystem.config.js from bots.json
function generateEcosystemConfig(botNameFilter = null) {
    if (!fs.existsSync(BOTS_JSON)) {
        console.error('profiles/bots.json not found. Run: npm run bootstrap:profiles');
        process.exit(1);
    }

    // Ensure logs directory exists
    if (!fs.existsSync(LOGS_DIR)) {
        fs.mkdirSync(LOGS_DIR, { recursive: true });
    }

    const content = fs.readFileSync(BOTS_JSON, 'utf8');
    const config = parseJsonWithComments(content);
    let bots = (config.bots || []).filter(b => b.active !== false);

    // Filter to specific bot if name provided
    if (botNameFilter) {
        bots = bots.filter(b => b.name === botNameFilter);
        if (bots.length === 0) {
            console.error(`Bot '${botNameFilter}' not found or not active in profiles/bots.json`);
            process.exit(1);
        }
    } else if (bots.length === 0) {
        console.error('No active bots found in profiles/bots.json');
        process.exit(1);
    }

    const apps = bots.map((bot, index) => {
        const botName = bot.name || `bot-${index}`;
        return {
            name: botName,
            script: path.join(ROOT, 'bot.js'),
            args: botName,
            cwd: ROOT,
            max_memory_restart: '250M',
            watch: false,
            autorestart: true,
            error_file: path.join(LOGS_DIR, `${botName}-error.log`),
            out_file: path.join(LOGS_DIR, `${botName}.log`),
            log_date_format: 'YY-MM-DD HH:mm:ss.SSS',
            merge_logs: false,
            combine_logs: true,
            max_restarts: 13,
            min_uptime: 86400000,
            restart_delay: 3000
        };
    });

    const ecosystemContent = `// Auto-generated by pm2.js - DO NOT EDIT
// Regenerate with: node pm2.js or node dexbot.js pm2
module.exports = { apps: ${JSON.stringify(apps, null, 2)} };
`;

    fs.writeFileSync(ECOSYSTEM_FILE, ecosystemContent);
    console.log(`Ecosystem configuration generated`);
    return apps;
}

// Authenticate master password (assumes BitShares already connected)
async function authenticateWithoutWait() {
    const chainKeys = require('./modules/chain_keys');

    try {
        const password = await chainKeys.authenticate();
        console.log('Master password authenticated');
        return password;
    } catch (err) {
        if (err.message && err.message.includes('No master password set')) {
            console.error('No master password set. Run: node dexbot.js keys');
            process.exit(1);
        }
        throw err;
    }
}

// Start PM2 with environment
function startPM2(masterPassword) {
    return new Promise((resolve, reject) => {
        const env = { ...process.env, MASTER_PASSWORD: masterPassword };
        const pm2 = spawn('pm2', ['start', ECOSYSTEM_FILE], {
            cwd: ROOT,
            env,
            stdio: 'inherit',
            detached: false
        });

        pm2.on('close', code => {
            if (code === 0) {
                // Ensure we disconnect from PM2's file descriptors
                setImmediate(resolve);
            } else {
                reject(new Error(`PM2 exited with code ${code}`));
            }
        });

        pm2.on('error', reject);
    });
}

// Check if PM2 is installed (local or global)
function checkPM2Installed() {
    try {
        require.resolve('pm2');
        return true;
    } catch (e) {
        // Check if pm2 is available in PATH
        const { execSync } = require('child_process');
        try {
            execSync('pm2 --version', { stdio: 'ignore' });
            return true;
        } catch (err) {
            return false;
        }
    }
}

// Prompt to install PM2
async function installPM2() {
    const readline = require('readline');
    const { spawn } = require('child_process');

    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    return new Promise((resolve, reject) => {
        rl.question('PM2 is not installed. Install now? (y/n): ', (answer) => {
            rl.close();

            if (answer.toLowerCase() !== 'y') {
                console.log('PM2 installation cancelled. Run: npm install -g pm2');
                process.exit(1);
            }

            console.log('Installing PM2...');
            const npm = spawn('npm', ['install', '-g', 'pm2'], { stdio: 'inherit' });

            npm.on('close', (code) => {
                if (code === 0) {
                    console.log('PM2 installed successfully!');
                    resolve();
                } else {
                    reject(new Error('PM2 installation failed'));
                }
            });

            npm.on('error', reject);
        });
    });
}

// Main
async function main(botNameFilter = null) {
    console.log('='.repeat(50));
    console.log('DEXBot2 PM2 Launcher');
    if (botNameFilter) {
        console.log(`Starting bot: ${botNameFilter}`);
    }
    console.log('='.repeat(50));
    console.log();

    // Step 0: Wait for BitShares connection (suppress BitShares client logs)
    const { waitForConnected } = require('./modules/bitshares_client');
    console.log('Connecting to BitShares...');

    // Suppress BitShares console output during connection
    const originalLog = console.log;
    console.log = (...args) => {
        // Only suppress BitShares-specific messages
        const msg = args.join(' ');
        if (!msg.includes('bitshares_client') && !msg.includes('modules/')) {
            originalLog(...args);
        }
    };

    await waitForConnected(30000);

    // Restore console output
    console.log = originalLog;
    console.log('Connected to BitShares');
    console.log();

    // Step 1: Check PM2
    if (!checkPM2Installed()) {
        console.error('PM2 is not installed');
        await installPM2();
    }

    // Step 2: Generate ecosystem config
    console.log('Generating ecosystem configuration...');
    const apps = generateEcosystemConfig(botNameFilter);
    console.log(`Number active bots: ${apps.length}`);
    console.log();

    // Step 3: Authenticate
    console.log('Authenticating master password...');
    const masterPassword = await authenticateWithoutWait();
    console.log();

    // Step 3: Start PM2
    console.log('Starting PM2...');
    await startPM2(masterPassword);

    console.log();
    console.log('='.repeat(50));
    console.log('DEXBot2 started successfully!');
    console.log('='.repeat(50));
    console.log();
}

// Run if called directly
if (require.main === module) {
    // Extract optional bot-name parameter from command line
    const botNameFilter = process.argv[2] || null;

    main(botNameFilter).then(() => {
        // Close stdin to prevent hanging
        if (process.stdin) process.stdin.destroy();
        // Exit immediately
        process.exit(0);
    }).catch(err => {
        console.error('Error:', err.message);
        process.exit(1);
    });
}

module.exports = { main, generateEcosystemConfig, authenticateWithoutWait };
